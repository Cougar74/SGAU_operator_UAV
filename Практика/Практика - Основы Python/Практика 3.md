---
tags:
Создана: 2025-11-30
Номер ПЗ: "#3"
Тема ПЗ: Стандартные библиотеки и функции
---
# Стандартные библиотеки и функции
## Импортирование
**Импортирование** в Python позволяет использовать код из других модулей и пакетов в вашей программе. Это фундаментальная концепция для организации кода и повторного использования.
### Импорт всего модуля
```python
import math

result = math.sqrt(25)
print(result)  # 5.0
```
### Импорт c псевдонимом
```python
import math as mat

result = mat.sqrt(25)
print(result)  # 5.0
```
### Импорт конкретных объектов
```python
from math import sqrt, pi

result = sqrt(9)
print(result)
print(pi)  # 3.141592653589793
```
### Импорт всех объектов из модуля
> [!attention]
> Такой способ не рекомендуется, так как может привести к конфликтам имен.

```python
from math import *

result = cos(0) + sin(0)
```
## `os`
Модуль `os` предоставляет множество функций для работы с операционной системой, причём их поведение, как правило, не зависит от ОС, поэтому программы остаются переносимыми.
`os.name` – имя операционной системы. Доступные варианты: `'posix'`, `'nt'`, `'mac'`, `'os2'`, `'ce'`, `'java'`.
`os.getlogin()` – имя пользователя, вошедшего в терминал (Unix).
`os.getpid()` – текущий id процесса.
`os.uname()` – информация об ОС. возвращает объект с атрибутами: `sysname` - имя операционной системы, `nodename` - имя машины в сети (определяется реализацией), `release` - релиз, `version` - версия, machine - `идентификатор` машины.
`os.getcwd()` – текущая рабочая директория.
`os.listdir()` – список файлов и директорий в папке.
`os.mkdir(path)` – создаёт директорию. `OSError`, если директория существует.
`os.remove(path)` – удаляет путь к файлу.
`os.rename(src, dst)` – переименовывает файл или директорию из **src** в **dst**.
## `datetime`
Модуль `datetime` предоставляет классы для обработки времени и даты разными способами. Поддерживается и стандартный способ представления времени, однако больший упор сделан на простоту манипулирования датой, временем и их частями.
### Получаем текущее время и дату
```python
import datetime

dt = datetime.datetime.today()
print(f'{dt}')
print(f'{dt.year} / {dt.month} / {dt.day}')
print(f'{dt.hour} : {dt.minute} : {dt.second}')
print(f'{dt.date()}')
print(f'{dt.time()}')
```
### Преобразовать текущее время в секунды
```python
# Количество секунд считается с 01.01.1970
dt = datetime.datetime.now()
print(f'{dt}')

print(f'Секунд: {dt.timestamp()})
```

> [!FAQ]- Почему дата в компьютерах считается с 1 января 1970 года?
> Дата 1 января 1970 года - это «эпоха Unix», точка отсчёта времени для большинства компьютерных систем, потому что она была выбрана в качестве удобного начала для систем, основанных на операционной системе Unix.
> Инженеры Unix произвольно выбрали эту дату, потому что она была удобна для работы, а также была ближайшей «круглой» датой в то время, когда велась разработка системы.
>  Благодаря тому, что Unix стала одной из основных платформ для интернета, этот формат исчисления времени стал широко распространён и используется до сих пор в различных операционных системах.
### Форматирование дат и времени
`strftime()` - преобразование в строку
```python
from datetime import datetime

now = datetime.now()

# Основные форматы
print(now.strftime("%d.%m.%Y"))
print(now.strftime("%d/%m/%y"))
print(now.strftime("%H:%M:%S"))
print(now.strftime("%Y-%m-%d %H:%M:%S"))

# Полные названия
print(now.strftime("%A, %d %B %Y"))
print(now.strftime("%a, %d %b %Y"))

# С локализацией (русская локаль)
print(now.strftime("%d %B %Y"))
```

`strptime()` - парсинг из строки
```python
from datetime import datetime

# Парсинг из различных форматов
date_str = "2025-12-31 23:59:59"
dt = datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
print(dt)

# Разные форматы
dt1 = datetime.strptime("31/12/2025", "%d/%m/%Y")
dt2 = datetime.strptime("Dec 31 2025", "%b %d %Y")
dt3 = datetime.strptime("31 декабря 2025", "%d %B %Y") 
```
## `re`
Регулярные выражения – это мощный инструмент для поиска и обработки текста. Библиотека `re` в Python предоставляет все необходимые функции для работы с **regex**.
### Специальные символы (метасимволы)
```text
.       Любой символ, кроме новой строки
^       Начало строки
$       Конец строки
*       0 или более повторений
+       1 или более повторений
?       0 или 1 повторение
{m}     Ровно m повторений
{m,n}   От m до n повторений
[]      Набор символов (любой из)
|       ИЛИ (альтернатива)
()      Группировка
\       Экранирование специальных символов
```
Также есть дополнительные конструкции, которые позволяют сокращать регулярные выражения:
- \d - соответствует любой одной цифре и заменяет собой выражение `[0-9]`;
- \D - исключает все цифры и заменяет `[^0-9]`;
- \w - заменяет любую цифру, букву, а также знак нижнего подчёркивания;
- \W - любой символ кроме латиницы, цифр или нижнего подчёркивания;
- \s - соответствует любому пробельному символу;
- \S - описывает любой непробельный символ;
- \b - граница слова.

Применяется для:
- для определения нужного формата, например, телефонного номера или email-адреса;
- для разбивки строк на подстроки;
- для поиска, замены и извлечения символов;
- для быстрого выполнения нетривиальных операций.
### Основные функции модуля
#### `re.match()`
Этот метод ищет по заданному шаблону в начале строки.
```python
result = re.match(r'Это', 'Это вам не Это...')
result
```
Искомая подстрока найдена. Чтобы вывести её содержимое, применим метод `group()` (мы используем `r` перед строкой шаблона, чтобы показать, что это «сырая» строка в Python).
```python
result.group(0)
```
Также есть методы `start()` и `end()` для того, чтобы узнать начальную и конечную позицию найденной строки.
```python
print(f'{result.start() = }')
print(f'{result.end() = }')
```
#### `re.search()`
Метод похож на `match()`, но ищет не только в начале строки. Метод `search()` ищет по всей строке, но возвращает только первое найденное совпадение.
```python
result = re.search(r'вам', 'Это вам не Это...')
print(f'{result.group(0) = }')
```
#### `re.findall()`
Возвращает список всех найденных совпадений. У метода `findall()` нет ограничений на поиск в начале или конце строки.
```python
result = re.findall(r'Это', 'Это вам не Это...')
print(f'{result = }')
```
#### `re.split()`
Этот метод разделяет строку по заданному шаблону.
```python
result = re.split(r'е', 'Четырехсотпятидесятисемимиллиметровое')
print(f'{result = }')
```
#### `re.sub()`
Ищет шаблон в строке и заменяет его на указанную подстроку. Если шаблон не найден, строка остается неизменной.
```python
result = re.sub(r'\s+', ' ', 'Текст   с    лишними    пробелами    и   знаками...  !')
print(f'{result = }')
```
#### `re.compile()`
Мы можем собрать регулярное выражение в отдельный объект, который может быть использован для поиска. Это также избавляет от переписывания одного и того же выражения.
```python
pattern = re.compile(r'\b[А-Я][а-я]*')
result = pattern.findall('Это вам не Это...')
print(f'{result = }')
```
## `numpy`
**NumPy** –  это библиотека Python с открытым исходным кодом, которая используется практически во всех областях науки и техники. Это универсальный стандарт для работы с числовыми данными в Python.
Библиотека **NumPy** содержит многомерные массивы и матричные структуры данных. **NumPy** можно использовать для выполнения множества математических операций с массивами. Он добавляет в Python мощные структуры данных, гарантирующие эффективные вычисления с массивами и матрицами, и предоставляет огромную библиотеку высокоуровневых математических функций, которые работают с этими массивами и матрицами.
```python
import numpy as np
```
Чтобы создать массив необходимо обернуть существующий список с помощью `np.array()`:
```python
a = np.array([1, 2, 3])
print(f'{type(a) = }')
print(f'{a.shape = }')
print(f'{a[0], a[1], a[2]}')

a[0] = 5
print(a)

b = np.array([[1,2,3],[4,5,6]])
print(f'{b.shape = }')
print(f'{b[0, 0], b[0, 1], b[0, 2]}')
```
Рассмотрим некоторые функции для создания специфичных матриц:
- `np.arange()` – вектор из натуральных чисел;
- `np.zeros()` – создаем нулевую матрицу заданного размера;
- `np.one()` – единичная матрица заданного размера;
- `np.full()` – матрица заданного размера наполненная заданным числом;
- `np.eye()` – матрица идентичности заданного размера.
```python
n_nums = np.arange(10)
all_zeros_2x2 = np.zeros((2, 2))
all_ones_1x2 = np.ones((1, 2))
all_seven_2x2 = np.full((2, 2), 7)
identity_mat = np.eye(2)

print(f'{n_nums = }\n')
print(f'{all_zeros_2x2 = }\n')
print(f'{all_ones_1x2 = }\n')
print(f'{all_seven_2x2 = }\n')
print(f'{identity_mat = }')
```
Также есть модуль `np.random` для генерации случайных чисел
```python
rand_mat = np.random.random((2, 2))
rand_mat_3x3 = np.random.randint(0,10, (3,3))

print(f'{rand_mat = }\n')
print(f'{rand_mat_3x3 = }')

vec = np.arange(42) * 10
print(f'{vec = }')


print(f'{np.random.choice(vec, 3) = }')
print(f'{np.random.choice(vec, 3) = }')
```
### Обращение к элементам матриц
```python
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

# Эквивалентные выражения
print(a[0][2])
print(a[0, 2])

# Срезы
b = a[:2, 1:3]
print(b)

# Срез массива numpy - это представление оригинального массива
# Попытка изменить там данные приведет к изменению оригинального массива
print(a[0, 1])
b[0, 0] = 77
print(a[0, 1])

print(a[1, :])
print(a[1:2, :])
print(a[:, 1])
print(a[:, 1:2])
```
### Индексирование
```python
a = np.array([[1,2], [3, 4], [5, 6]])

# Булевы маски
bool_idx = (a > 2)
print(bool_idx)

# Используя эту матрицу, мы можем получить вектор из элементов матрицы a, которые соответсвуют условию
print(a[bool_idx])

# ... или одной строкой
print(a[a > 2])
```
Для булевых масок определены следующие логические операции:
- `&` - логическое "и"
- `|` - логическое "или"
- `~` - логическое отрицание.
```python
a = np.array([[1,2], [3, 4], [5, 6]])

bm_1 = (a>2)
bm_2 = (a<5)

print(bm_1)
print(bm_2)

print(bm_1 & bm_2)
print(a[bm_1 & bm_2])

print(a[(a<2) & (a>5)])
```
**Fancy indexing** - индексирование массивом целых чисел.
```python
a = np.arange(0, 100, 10)
print(a)

b = a[[2, 3, 2, 4, 2]]
print(b)
```
### Изменение форм и размерностей массивов
Изменить форму массива можно функцией `reshape(dim)`, где `dim` - кортеж с новой размерностью массива. Будет возвращена копия объекта, но область данных останется неизменной, а изменения в оригинальном массиве будут отражены в порожденной копии. При этом, если одна из размерностей массива неизвестна, на ее месте можно указать ```-1```.
Кортеж с текущей размерностью массива находится в его свойстве `shape`.
"Плоское" представление массива вернет метод `ravel()`, а метод `flatten()` вернет его копию.
```python
a = np.arange(9)
print(a)
b = a.reshape((3,3))

a[5] = 100
print(b)

r = b.ravel()
f = b.flatten()
print(f)

f[4] = 200
print(a)

r[4] = 200
print(a)
```
### Конкатенация  и разбиение массивов
Используются функции `concatenate()` и `split()`.
```python
arr1 = np.array([[1,2,3], [4,5,6]])
arr2 = np.array([[7,8,9], [10,11,12]])

concats_0 = np.concatenate([arr1, arr2], axis= 0)
print(concats_0)

concats_1 = np.concatenate([arr1, arr2], axis= 1) 
print(concats_1)

first, second, third = np.split(concats_0, [1, 2], axis=0)
print(first)
print(second)
print(third)
```
### Типы данных numpy
```python
# numpy сам подберет тип данных
x = np.array([1, 2])
print(x.dtype)

# Здесь numpy выберет float64
x = np.array([1.0, 2.0])
print(x.dtype)

x = np.array([1, 2], dtype=np.float64)   
print(x.dtype)

# конвертация типов производится методом astype(), он возвращает копию текущего массива
y = x.astype(dtype=np.int32)

x = np.array([1, 2, 2.5, 'john'])

x.nan
```
### Операции с массивами numpy
Выполняются для каждого элемента массива или среза
```python
x = np.array([[1,2],[3,4]], dtype=np.float64)
y = np.array([[5,6],[7,8]], dtype=np.float64)

print(np.add(x, y))
print(x + y)

print(np.sqrt(x))
print(np.exp(x))
print(np.log(x))
```
### Операции из области линейной алгебры
Умножение матриц, скалярное произведение векторов (как частный случай умножения матриц), транспонирование - базовые функции пакета `numpy`.
В модуле `numpy.linalg` еще есть встроенные функции для расчетов рангов матриц, определителей, вычисления собственных чисел, а также для решения линейных уравнений:
 - `np.linalg.solve(A, b)` - вычисляет единственное решение системы линейных уравнений, где `A` - квадратная матрица коэффициентов, `b` - вектор значений
 - `np.linalg.matrix_rank(A)` - вычисляет ранг матрицы
 - `np.linalg.inv(A)` - вычисляет обратную матрицу
 - `np.linalg.eig(A)` - вычисляет собственный вектор или собственное число матрицы
```python
x = np.array([[1,2],[3,4]])
y = np.array([[5,6],[7,8]])

v = np.array([9,10])
w = np.array([11, 12])

# Скалярное произведение векторов
print(v.dot(w))
print(np.dot(v, w))

# Умножение матрицы на вектор
print(x.dot(v))
print(np.dot(x, v))

# Умножение матриц
print(x.dot(y))
print(np.dot(x, y))
```
### Бродкастинг (broadcasting)
 В русскоязычной литературе этот термин также встречается как "укладывание"
```python
# Добавим вектор v к каждой строке матрицы x
# результат запишем в матрицу y

x = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
v = np.array([1, 0, 1])

# Добавление вектора v к каждой строке матрицы x называется бродкастинг
y = x + v  
print(y)
```
### Агрегатные вычисления
```python
x = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])

print(x.sum())
print(x.mean())
print(x[2].sum())
print(np.sum(x[:, 1]))

a_vec = (np.random.random(10) * 100).astype(dtype=np.int64)
print(a_vec)
print(a_vec.max())
print(a_vec.argmax())

m = np.random.randint(0, 10, (3, 3))
m.argmax()
```
### Сортировка
```python
a_vec = (np.random.random(10) * 100).astype(dtype=np.int64)

print(a_vec)
print(np.sort(a_vec))
print(a_vec)
print(a_vec.argsort(reverse=True))
print(a_vec[a_vec.argsort()[:5]])
```
## `matplotlib`
```python
import matplotlib.pyplot as plt
```
Графики строятся функцией `plot()`. Ей достаточно передать единственный параметр с вектором данных для отображения
```python
data = np.arange(10) ** 2
plt.plot(data)
```
Также ей можно передать матрицу
```python
plt.plot(np.array([[1, 2, 3, 4], [1, 4, 9, 16]]))
```
Для построения полноценного графика функции $y = f(x)$ необходимо вызывать `plot` с двумя параметрами plot(x, f(x)). При этом удобно задавать диапазон переменной c помощью метода `numpy.linspace`.
```python
x = np.linspace(-5, 5, 50)
print(x)

plt.plot(x, x*2)
plt.show()
```
На одном поле можно строить несколько графиков:
```python
x = np.linspace(0, 2, 100)

plt.plot(x, x) # линейная зависимость
plt.plot(x, x ** 2) # квардратичная зависимость
plt.plot(x, x ** 3) # кубическая
plt.plot(x, np.exp(x)) # экспоненциальная
plt.show()
```
Простейшую гистограмму можно построить из массива `numpy` функцией `hist()`.
```python
a_rand = np.random.randn(10000)
plt.hist(a_rand)
```
Диаграмму рассеяния можно нарисовать  функцией `scatter()`
```python
plt.scatter(np.arange(30), np.arange(30) + 3 * np.random.randn(30))
```
Для рисования стрелок используем функцию `arrow()`
```python
plt.arrow(0,0, 3,1, head_width=0.2, color='r', length_includes_head=True)
plt.arrow(0,0, 1,3, head_width=0.2, color='g', length_includes_head=True)
plt.arrow(0,0, 4,4, head_width=0.2, color='b', length_includes_head=True)
plt.show()
```
Другие полезные типы графиков
```python
x = np.linspace(-1, 1)

fig, axes = plt.subplots(1, 3, figsize = (12, 4))

# закрасить пространство между графиками
axes[0].fill_between(x, np.sqrt(np.abs(x)), x**2, color="green", alpha=0.5);
axes[0].set_title("fill_between");

# столбчатая диаграмма
axes[1].bar(np.arange(-5, 6), np.arange(-5, 6)**3, align="center", width=0.5, alpha=0.5)
axes[1].set_title("bar")

# ступенчатый график
axes[2].step(x, np.sqrt(np.abs(x)), lw=1)
axes[2].set_title("step")

fig.tight_layout()
```
### Настройка пространства `numpy` и отображения графиков
Размеры выводимых графиков могут быть настроены как глобально, так и для каждой иллюстрации отдельно. Снова построим линейный график и расстроимся из-за его непропорциональности (и других визуальных недостатков)
```python
plt.plot(np.arange(10))
```
Перед построением графика проинициализируйте иллюстрацию, вызвав функцию `figure()` с параметром `figsize`, в котором можно передать размеры картинки в дюймах. Соотношение и будет пропорцией отображаемого графика.
```python
plt.figure(figsize=(10,10))
plt.plot(np.arange(10))
plt.show()
```
Также можно задать нелинейные пропорции осей: логарифмическую, симметричную логарифмическую, логистическую и т.д.
```python
x = np.linspace(-2, 2, 40)

plt.figure(figsize=(10,10))
plt.plot(x, x+1)
plt.plot(x, np.exp(x))
plt.yscale('log')
plt.show()
```
Давайте оформим график:
 - зададим диапазон отображения аргументов и функции;
 - отобразим координатную сетку и оси;
 - зададим метки для осей и самой иллюстрации;
 - выведем легенду.
```python
plt.figure(figsize=(10,10))

# зададим диапазон по осям, с полями
margin = .5
plt.ylim((-1.5, 4.5))
plt.xlim((x.min() - margin, x.max() + margin))

# отобразим координатную сетку и оси
plt.grid(color='grey', linestyle='-', linewidth=1)
plt.axhline(0,color='black') # x = 0
plt.axvline(0,color='black') # y = 0

# зададим метки для осей и самой иллюстрации
plt.xlabel("$x$, аргумент")
plt.ylabel("$f(x)$, функция") # Label for y-axis.
plt.title('Линейная и эскпоненциальная зависимости')

# построим график
plt.plot(x, x+1, label="$f(x) = x$")
plt.plot(x, np.exp(x), label="$f(x) = e^x$")

# разместим легенду
plt.legend(loc='best')

plt.show()
```
### Основные объекты `matplotlib`
Объект `figure` - сама иллюстрация.
Объект `axes` - один из графиков на этой иллюстрации, именно к этому объекту мы будем применять все те методы, с которыми мы ознакомились выше:
- `.plot()`
- `.ylim()` и `.xlim()`
- `.title()`, `.xlabel()`, `.ylabel()`
- и т.д.

Получить экземпляр объекта `figure` и требуемое количество `axes` можно из функции `subplots()`, ей надо передать количество графиков по горизонтали и по вертикали. Она возвращает кортеж из иллюстрации и подграфиков - если их несколько, она вернет их список вторым членом кортежа.
Построим наши графики в соответствии с объектно-ориентированным подходом.
```python
fig, ax = plt.subplots(1,1)

fig.set_size_inches(10,10)

ax.plot(x, x+1, label="$f(x) = x$")
ax.plot(x, np.exp(x), label="$f(x) = e^x$")

plt.show()
```
Перенесем все оформление в функцию
```python
def my_plotter(ax, data1, data2, **param_dict):
	ax.grid(color='grey', linestyle='-', linewidth=1)
	ax.axhline(0,color='black')
	ax.axvline(0,color='black')

	ax.set_xlabel("$x$, аргумент")
	ax.set_ylabel("$f(x)$, функция")

	out = ax.plot(data1, data2, **param_dict)

	return out
```
И наконец построим график
```python
fig, ax = plt.subplots(1,1)

fig.set_size_inches(10,10)
ax.set_title('Линейная и эскпоненциальная зависимости')

xx = x + 1

margin = .5
ax.set_ylim((xx.min() - margin, xx.max() + margin))
ax.set_xlim((x.min() - margin, x.max() + margin))

my_plotter(ax, x, xx, label="$f(x) = x$")
my_plotter(ax, x, np.exp(x), label="$f(x) = e^x$")

ax.legend(loc='best')
plt.show()
```
### Инфографика
Круговая диаграмма (**pie chart**) строится функцией `pie()`. Направление обхода по умолчанию - против часовой стрелки. Параметр `explode` позволяет задать смещение для некоторых элементов диаграммы. При этом в `sizes` могут быть совершенно любые числа, не обязательно процентное соотношение.
```python
# сделаем графики побольше
plt.rcParams['figure.figsize'] = (10.0, 10.0)

labels = 'Для ежа', 'Для ужа', 'Для моржа', 'Для стрижа'
sizes = [15, 30, 45, 10]
explode = (0, 0.1, 0, 0)

fig1, ax1 = plt.subplots()
ax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)
plt.show()
```
Столбчатые диаграммы с распределением по группам строятся той же функцией `bar()`, но для построения "надстройки" ей надо передать параметр `bottom`, который будет содержать данные для "основной" диаграммы
```python
N = 5
menMeans = (20, 35, 30, 35, 27)
womenMeans = (25, 32, 34, 20, 25)
ind = np.arange(N)
width = 0.35

p1 = plt.bar(ind, menMeans, width)
p2 = plt.bar(ind, womenMeans, width, bottom=menMeans)

plt.ylabel('Баллы')
plt.title('Баллы по группе и полу')
plt.xticks(ind, ('Г1', 'Г2', 'Г3', 'Г4', 'Г5'))
plt.yticks(np.arange(0, 81, 10))
plt.legend((p1[0], p2[0]), ('М', 'Ж'))
plt.show()
```
### Классификация информации цветом и формой
Обратите внимание на второй параметр функции `plot()`
```python
data = np.random.randn(30).cumsum()

plt.plot(data, 'r--', label='Default')
plt.plot(data, 'b-', drawstyle='steps-post', label='steps-post')
plt.legend(loc='best')
```
Можно добавить маркеры
```python
plt.plot(data, color='r', linestyle='dotted', label='Default', marker='o')
```
В задачах классификации иногда нужно представить пространственное распределение тех или иных признаков
```python
rng = np.random.RandomState(0)
n = 30

for i, marker in enumerate(['o', '.', ',', 'x', '+', 'v', '^', '<', '>', 's', 'd']):
	plt.plot(data + 0.2*(i), data - 0.05*(i), marker, label=f"{marker = }")

plt.legend(numpoints=1)
plt.xlim(0, 1.8)
```
### 3D-графики
Точно также создаем `axes`
```python
fig = plt.figure()
ax = plt.axes(projection='3d')
```
3-е измерение функции строится поверх конструкции `meshgrid`, которая по сути является координатной сеткой для каждой точки функции
```python
x = np.arange(1, 5).astype(dtype=np.float64)
y = np.arange(7, 4, -1).astype(dtype=np.float64)
XY = np.meshgrid(x, y)

XY
```
Контуры поверхности строятся функциями `ax.contour3D(X, Y, Z)`,  `plot_surface(X, Y, Z)`, `plot_wireframe(X, Y, Z)` и многими другими.
```python
x = np.linspace(-6, 6, 30)
y = np.linspace(-6, 6, 30)
X, Y = np.meshgrid(x, y)

def f(x, y):
	return np.sin(np.sqrt(x ** 2 + y ** 2))

Z = f(X, Y)
fig = plt.figure()
ax = plt.axes(projection='3d')

# ax.contour3D(X, Y, Z, 50, cmap='binary')
# ax.plot_surface(X, Y, Z)
ax.plot_wireframe(X, Y, Z, rstride=1, cstride=1)

ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_zlabel('z')
```
Также можно делать "температурные карты" - **heatmaps**, используя встроенные в `matplotlib` цветовые схемы. Проиллюстрируем это на примере с параболоидом
```python
m = 3
n = 2
b = 1
d = 0.75

def f(x, y):
	return (x + m) ** 2 + (y * d + n) ** 2 + b

x = np.linspace(-6-m, 6-m, 100)
y = np.linspace(-6-n, 6-n, 100)

X, Y = np.meshgrid(x, y)
Z = f(X, Y)

cm = plt.cm.get_cmap('viridis')
plt.scatter(X, Y, c=Z, cmap=cm)
plt.colorbar()
plt.show()
```
Также эти данные можно визуализировать горизонталями
```python
cp = plt.contour(X, Y, Z)
plt.clabel(cp, inline=1, fontsize=10)
plt.xlabel('X')
plt.ylabel('Y')
plt.show()
```
Можно комбинировать оба способа
```python
cp = plt.contour(X, Y, Z, colors='black', linestyles='dashed', linewidths=1)
plt.clabel(cp, inline=1, fontsize=10)
cp = plt.contourf(X, Y, Z, )
plt.xlabel('X')
plt.ylabel('Y')
plt.show()
```