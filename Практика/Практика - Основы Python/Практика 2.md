---
tags:
Создана: 2025-11-29
Номер ПЗ: "#2"
Тема ПЗ: Применение ООП
---
# ООП (Объектно-Ориентированное Программирование)
**ООП** – это парадигма программирования, в которой программа строится вокруг **объектов**, инкапсулирующих данные (атрибуты) и поведение (методы). 

Объектно-ориентированное программирование по праву считается одной из самых эффективных методологий создания программных продуктов. В объектно-ориентированном программировании вы создаете классы, описывающие реально существующие предметы и ситуации, а затем создаете объекты на основе этих описаний. При написании класса определяется общее поведение для целой категории объектов.
Когда вы создаете конкретные объекты на базе этих классов, каждый объект автоматически наделяется общим поведением; после этого вы можете наделить каждый объект уникальными особенностями на свой выбор.
Создание объекта на основе класса называется **созданием экземпляра**; таким образом, вы работаете с экземплярами класса.

Классы позволяют моделировать практически все что угодно. Начнем с написания простого класса `Dog`, представляющего собаку – не какую-то конкретную, а собаку вообще.
Что мы знаем о собаках? У них есть кличка и возраст. Также известно, что большинство собак умеют садиться и перекатываться по команде.
Эти два вида информации (кличка и возраст) и два вида поведения (сидеть и перекатываться) будут включены в класс `Dog`, потому что они являются общими для большинства собак. Класс сообщает Python, как создать объект, представляющий собаку. После того как класс будет написан, мы используем его для создания экземпляров, каждый из которых представляет одну конкретную собаку.
# Классы в Python
## Создание класса `Dog`
В каждом экземпляре, созданном на основе класса `Dog`, будет храниться кличка (`name`) и возраст (`age`); кроме того, в нем будут присутствовать методы `sit()` и `roll_over()`:
```python
class Dog():
    def __init__(self, name, age):
        # Инициализирует атрибуты name и age
        self.name = name
        self.age = age

    def sit(self):
        # Собака садится по команде
        print(f"{self.name} сел!")

    def roll_over(self):
        # Собака перекатывается по команде
        print(f"{self.name} сделал перекат!")
```
В этом коде есть много мест, заслуживающих нашего внимания. Прежде всего это само ключевое слово `class` и наше имя класса `Dog`. По общепринятым соглашениям имена, начинающиеся с символа верхнего регистра, в Python обозначают классы. Круглые скобки в определении класса пусты, потому что класс создается с нуля (без **наследования**).

### Метод `__init__()`
Функция, являющаяся частью класса, называется **методом**. Все, что вы узнали ранее о функциях, также относится и к методам; единственное практическое различие – способ вызова методов. Метод `__init__()` – специальный метод, который автоматически выполняется при создании каждого нового экземпляра на базе класса `Dog`.

Имя метода начинается и заканчивается двумя *символами подчеркивания*; эта схема предотвращает конфликты имен стандартных методов Python и методов ваших классов. Будьте внимательны: два символа подчеркивания должны стоять на каждой стороне `__init__()`. Если вы поставите только один символ подчеркивания с каждой стороны, то метод не будет вызываться автоматически при использовании класса, что может привести к появлению коварных ошибок.

Метод `__init__()` определяется с тремя параметрами: `self`, `name` и `age`. Параметр `self` обязателен в определении метода; он должен предшествовать всем остальным параметрам. Он должен быть включен в определение, потому что при будущем вызове метода `__init__()` (для создания экземпляра `Dog`) Python автоматически передает аргумент `self`.
При каждом вызове метода, связанного с классом, автоматически передается `self` – ссылка на экземпляр; она предоставляет конкретному экземпляру доступ к атрибутам и методам класса. Когда вы создаете экземпляр `Dog`, Python вызывает метод `__init__()` из класса `Dog`. Мы передаем `Dog()` кличку и возраст в аргументах; значение `self` передается автоматически, так что его передавать не нужно. Каждый раз, когда вы захотите создать экземпляр на основе класса `Dog`, необходимо предоставить значения только двух последних аргументов: `name` и `age`.
Каждая из двух переменных снабжена префиксом `self`. Любая переменная с префиксом `self` доступна для каждого метода в классе, и вы также сможете обращаться к этим переменным в каждом экземпляре, созданном на основе класса.
Конструкция `self.name = name` берет значение, хранящееся в параметре `name`, и сохраняет его в переменной name, которая затем связывается с создаваемым экземпляром. Процесс также повторяется с `self.age = age`. Переменные, к которым вы обращаетесь через экземпляры, также называются **атрибутами**.

В классе `Dog` также определяются два метода: `sit()` и `roll_over()`. Так как этим методам не нужна дополнительная информация (кличка или возраст), они определяются с единственным параметром `self`. Экземпляры, которые будут созданы позднее, смогут вызывать эти методы. Пока методы `sit()` и `roll_over()` ограничиваются простым выводом сообщения о том, что собака садится или перекатывается. Тем не менее концепцию легко расширить для практического применения: если бы этот класс был частью компьютерной игры, то эти методы вполне могли бы содержать код для создания анимации садящейся или перекатывающейся собаки. А если бы класс был написан для управления роботом, то методы могли бы управлять механизмами, заставляющими робота-собаку выполнить соответствующую команду.
### Создание экземпляра класса
Считайте, что класс – это своего рода инструкция по созданию экземпляров. Соответственно класс `Dog` – инструкция по созданию экземпляров, представляющих конкретных собак.
Создадим экземпляр, представляющий конкретную собаку:
```python
my_dog = Dog('Банди', 4)

print(f'Мою собаку зовут {my_dog.name}.')
print(f'Моей собаке {my_dog.age} лет.')
```
Использованный в данном случае класс `Dog` был написан в предыдущем примере. В первой строчке мы приказываем Python создать экземпляр собаки с кличкой `'Банди'` и возрастом `4` года. В процессе обработки этой строки Python вызывает метод `__init__()` класса `Dog` с аргументами `'Банди'` и `4`.
Метод `__init__()` создает экземпляр, представляющий конкретную собаку, и присваивает его атрибутам `name` и `age` переданные значения. Затем Python возвращает экземпляр, представляющий собаку. Этот экземпляр сохраняется в переменной `my_dog`.
Здесь нелишне вспомнить соглашения по записи имен: обычно считается, что имя, начинающееся с символа верхнего регистра (например, `Dog`), обозначает класс, а имя, записанное в нижнем регистре (например, `my_dog`), обозначает отдельный экземпляр, созданный на базе класса.
### Обращение к атрибутам
Для обращения к атрибутам экземпляра используется **точечная** запись. В следующей строке мы обращаемся к значению атрибута `name` экземпляра `my_dog`:
```python
my_dog.name
```
Точечная запись часто используется в Python. Этот синтаксис показывает, как Python ищет значения атрибутов. В данном случае Python обращается к экземпляру `my_dog` и ищет атрибут `name`, связанный с экземпляром `my_dog`. Это тот же атрибут, который обозначался `self.name` в классе `Dog`.
### Вызов методов
После создания экземпляра на основе класса `Dog` можно применять точечную запись для вызова любых методов, определенных в `Dog`:
```python
my_dog.sit()
my_dog.roll_over()
```
Для вызова метода укажите экземпляр (в данном случае `my_dog`) и вызываемый метод, разделив их точкой. В ходе обработки `my_dog.sit()` Python ищет метод `sit()` в классе `Dog` и выполняет его код. Строка `my_dog.roll_over()` интерпретируется аналогичным образом.
Это очень полезный синтаксис. Если атрибутам и методам были присвоены содержательные имена (например, `name`, `age`, `sit()` и `roll_over()`), разработчик сможет легко понять, что делает блок кода – даже если он видит этот блок впервые.
### Создание нескольких экземпляров
На основе класса можно создать столько экземпляров, сколько вам потребуется. Создадим второй экземпляр `Dog` с именем `your_dog`:
```python
my_dog = Dog('Банди', 4)
your_dog = Dog('Чарли', 7)

print(f'Мою собаку зовут {my_dog.name}.')
print(f'Моей собаке {my_dog.age} лет.')
my_dog.sit()

print('---'*10)

print(f'Твою собаку зовут {your_dog.name}.')
print(f'Твоей собаке {your_dog.age} лет.')
your_dog.sit()
```
В этом примере создаются два экземпляра с именами `Банди` и `Чарли`. Каждый экземпляр обладает своим набором атрибутов и способен выполнять действия из общего набор.
Даже если второй собаке будет назначено то же имя и возраст, Python все равно создаст отдельный экземпляр класса `Dog`. Вы можете создать сколько угодно экземпляров одного класса при условии, что эти экземпляры хранятся в переменных с разными именами или занимают разные позиции в списке либо словаре.
# Основные парадигмы ООП
## Наследование
Работа над новым классом не обязана начинаться с нуля. Если класс, который вы пишете, представляет собой специализированную версию ранее написанного класса, вы можете воспользоваться **наследованием**. Один класс, наследующий от другого, автоматически получает все атрибуты и методы первого класса. Исходный класс называется **родителем**, а новый класс – **потомком**. Класс-потомок наследует атрибуты и методы родителя, но при этом также может определять собственные атрибуты и методы.
```python
class Car():
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
        self.speed = 0

    def get_descriptive_name(self):
        return f"{self.year} {self.manufacturer} {self.model}"

    def get_speed(self):
        print(f'Машина едет со скоростью {self.speed} км/ч')

    def update_speed(self, new_value):
        self.speed = new_value
        print(f'Новое значение скорости {self.speed}')
        
class ElectricCar(Car):
    def __init__(self, make, model, year):
        super().__init__(make, model, year)
        self.battery = 100

    def get_battery(self):
        print(f'Заряд батареи {self.battery}%')

    def update_battety(self, new_value):
        self.battery = new_value
        print(f'Новое значение заряда батареи {self.speed}')

my_tesla = ElectricCar('Tesla', 'Model S', '2019')
my_tesla.get_battery()
my_tesla.get_speed()
```
Сначала описывается класс `Car`. При создании класса-потомка класс-родитель должен быть частью текущего файла, а его определение должно предшествовать определению класса-потомка в файле.
Затем описывается класс-потомок `ElectricCar`. В определении потомка имя класса-родителя заключается в круглые скобки. Метод `__init__()` получает информацию, необходимую для создания экземпляра `Car`.
Функция `super()` – специальная функция, которая позволяет вызвать метод родительского класса. Эта строка приказывает Python вызвать метод `__init__()` класса Car, в результате чего экземпляр `ElectricCar` получает доступ ко всем атрибутам класса-родителя. Имя `super` происходит из распространенной терминологии: класс-родитель называется **суперклассом**, а класс-потомок – **подклассом**.
## Инкапсуляция
В языках программирование существует такое понятие, как **область видимости**, т.е. это места где переменная будет доступна. Разделяют два вида:
- **Публичные** атрибуты (`self.name`) – доступны извне класса
- **Приватные** (`self.__secret`) – доступны только внутри класса
```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # приватный атрибут

    def deposit(self, amount):
        self.__balance += amount

    def get_balance(self):
        return self.__balance

account = BankAccount(1000)
account.deposit(500)
print(f'{account.get_balance() = }')
```
**Инкапсуляция** является фундаментальной концепцией объектно-ориентированного программирования, которая предполагает скрытие функционала и предотвращение прямого доступа извне к нему.
## Полиморфизм
**Полиморфизм** - разное поведение одного и того же метода в разных классах. Например, мы можем сложить два числа, и можем сложить две строки. При этом получим разный результат, так как числа и строки являются разными классами.
```python
class Bird:
    def fly(self):
        print("Птица летит")

class Airplane:
    def fly(self):
        print("Самолёт летит")

def make_fly(obj):  # полиморфная функция
    obj.fly()

make_fly(Bird())      # Птица летит
make_fly(Airplane())  # Самолёт летит
```
## Абстракция
**Абстракция** – это принцип объектно-ориентированного программирования, который скрывает сложность внутренней реализации и предоставляет упрощённый интерфейс. Она достигается с помощью **абстрактных классов** и **абстрактных методов**, которые определяют общий интерфейс, но требуют реализации специфичной логики в подклассах.

Абстрактные классы имеют ряд особенностей:
- Абстрактный класс не содержит всех реализаций методов, необходимых для полной работы, это означает, что он содержит один или несколько абстрактных методов. Абстрактный метод - это только объявление метода, без его подробной реализации.
- Абстрактный класс предоставляет интерфейс для подклассов, чтобы избежать дублирования кода. Нет смысла создавать экземпляр абстрактного класса.
- Производный подкласс должен реализовать абстрактные методы для создания конкретного класса, который соответствует интерфейсу, определенному абстрактным классом. Следовательно, экземпляр не может быть создан, пока не будут переопределены все его абстрактные методы.

Если упростить все эти особенности, то абстрактный класс определяет общий интерфейс для набора подклассов. Он предоставляет общие атрибуты и методы для всех подклассов, чтобы уменьшить дублирование кода. Он также заставляет подклассы реализовывать абстрактные методы, чтобы избежать каких-то несоответствий.
```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

# shape = Shape()  # Ошибка! Нельзя создать экземпляр абстрактного класса
circle = Circle(5)
print(circle.area())  # 78.5
```

# Методологии ООП
**Методология** в программировании – это система принципов, практик, процедур и правил, которые определяют, как подходить к процессу проектирования, разработки и сопровождения программного обеспечения.
**Для чего нужны методологии:**
- **Снижение сложности:** Разбиение большой задачи на управляемые части.
- **Предсказуемость результата:** Понимание того, что получится в конце и сколько на это уйдет времени/ресурсов.
- **Стандартизация:** Все члены команды говорят на одном языке и следуют одним правилам.
- **Повышение качества:** Код становится более читаемым, поддерживаемым и тестируемым.
- **Облегчение поддержки:** Легче вносить изменения и исправлять ошибки, так как структура проекта понятна.
- **Масштабируемость:** Возможность легко добавлять новый функционал и развивать проект.
Основными столпами служат изученная выше парадигма, которая представлена в **инкапсуляции**, **наследовании**, **полиморфизме** и **абстракции**.

Помимо парадигм существуют и различные наборы принципов проектирования в ООП.
**SOLID**
**SOLID** – это набор принципов объектно-ориентированного проектирования, которые помогают создавать гибкий, поддерживаемый и масштабируемый код.
**SOLID** – это акроним:
- **S** - **Single Responsibility (Принцип единственной ответственности):** Каждый класс должен иметь только одну причину для изменения. Он должен отвечать только за что-то одно.
- **O** - **Open/Closed (Принцип открытости/закрытости):** Классы должны быть открыты для расширения (через наследование, композицию), но закрыты для модификации. Не нужно лезть в рабочий код, чтобы добавить новую функциональность.
- **L** - **Liskov Substitution (Принцип подстановки Барбары Лисков):** Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности программы. Наследник должен дополнять, а не изменять поведение родителя.
- **I** - **Interface Segregation (Принцип разделения интерфейса):** Много специализированных интерфейсов лучше, чем один универсальный. Клиент не должен зависеть от методов, которые он не использует.
- **D** - **Dependency Inversion (Принцип инверсии зависимостей):** Зависимости должны строиться на абстракциях, а не на конкретных реализациях.

**DRY**
**DRY** (Don't Repeat Yourself – Не Повторяйся) – rаждая часть знания или логики в системе должна иметь единственное, однозначное, авторитетное представление.
Проще говоря: **Не копируй код. Не дублируй логику.**